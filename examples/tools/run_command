#!/bin/bash
# Run a shell command and return output
#
# SAFETY: This tool ALWAYS asks for user confirmation before executing.
# The confirmation prompt uses stdin, which is free since args come via env var.

if [[ "$1" == "--schema" ]]; then
  cat <<'EOF'
{
  "name": "run_command",
  "description": "Execute a shell command and return stdout. Requires user confirmation for safety.",
  "parameters": {
    "type": "object",
    "properties": {
      "command": {
        "type": "string",
        "description": "The shell command to execute"
      }
    },
    "required": ["command"]
  }
}
EOF
  exit 0
fi

# Read args from env var (preferred) or stdin (fallback)
if [[ -n "$CHIBI_TOOL_ARGS" ]]; then
  args="$CHIBI_TOOL_ARGS"
else
  args=$(cat)
fi

command=$(echo "$args" | jq -r '.command')

if [[ -z "$command" || "$command" == "null" ]]; then
  echo "Error: command parameter is required" >&2
  exit 1
fi

# Always ask for confirmation (safety critical - ignores CHIBI_VERBOSE)
echo "" >&2
echo "┌─────────────────────────────────────────────────────────────" >&2
echo "│ Tool: run_command" >&2
echo "│ Command: $command" >&2
echo "└─────────────────────────────────────────────────────────────" >&2
echo -n "Execute this command? [y/N] " >&2

# Read confirmation from stdin (now free since args come via env var)
read -r answer

if [[ "$answer" != "y" && "$answer" != "Y" ]]; then
  echo "Command cancelled by user" >&2
  exit 1
fi

# Execute and capture both stdout and stderr
eval "$command" 2>&1
